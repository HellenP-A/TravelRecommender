# -*- coding: utf-8 -*-
"""Recomendación de destinos - Proyecto Sistemas Basados en Conocimiento.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K8X6wE7yomSpUyE_EpHwHS5prXcF2Y5T

# Sistema Basado en Conocimientos para Planificación de Vacaciones

Hellen Aguilar Noguera

José Leonardo Araya Parajeles

Fernando Rojas Meléndez

Alejandro Villalobos Hernández

*Universidad CENFOTEC*

TODOS:
- Generar más datos con APIs (opcional) -> Leonardo
- Hacer un Docker file -> Alejandro o algo para que no haya que tener que subir el archivo para ejecutarlo o usar google drive -> Fernando
- Documentar mejor (tal vez en uno de estas secciones de texto) cuales son nuestras reglas, por ejemplo usar logica difusa, y el orden que se ejecutan -> Hellen
- Diagrama de conocimiento: este es un diagrama que detalla los criterios de inferencia, tales como reglas importantes, umbrales o árboles de probabilidad que aplican para la inferencia. -> Alejandro
- Agregar ejemplos documentados del script "Ejemplos: se deben facilitar ejemplos para verificar el funcionamiento y
reproducir el trabajo hecho hasta el punto del avance." Ejemplos de inputs para recomendacion. -> Fernando
- Modificar el documento de diseño (overleaf) con las nuevas adiciones https://www.overleaf.com/5719863953rtbvbmnhmpyn#d61ea3 -> Fernando

Limpieza de datos
===========================
Primero limpiamos y cambiamos el data set para que tenga más sentido para lo que queremos. El data set inicial es sobre detalles de viajes. Vamos a tomarlo como base para crear una base de datos de destinos y presupuestos para recomendaciones
"""

# import pandas as pd
# import re

# # Función para limpiar valores de costo eliminando caracteres no numéricos y convirtiendo a float
# def clean_cost(cost):
#     if pd.isna(cost):
#         return None
#     cleaned = re.sub(r'[^\d.]', '', str(cost))  # Elimina caracteres no numéricos excepto el punto decimal
#     try:
#         return float(cleaned)
#     except ValueError:
#         return None

# # Cargar el conjunto de datos original (reemplaza 'tu_archivo.csv' con la ruta real del archivo)
# df = pd.read_csv('Travel details dataset.csv')

# # Limpiar las columnas de costos
# df['Accommodation cost'] = df['Accommodation cost'].apply(clean_cost)
# df['Transportation cost'] = df['Transportation cost'].apply(clean_cost)

# # Extraer el mes de la columna Start date
# df['Month'] = pd.to_datetime(df['Start date']).dt.month

# # Estandarizar el tipo de transporte
# df['Transportation type'] = df['Transportation type'].str.lower().str.strip()
# df['Transportation type'] = df['Transportation type'].replace({'plane': 'flight', 'airplane': 'flight'})

# # Filtrar solo los viajes con transporte en avión
# df = df[df['Transportation type'] == 'flight']

# # Eliminar filas con valores faltantes en columnas esenciales
# essential_columns = [
#     'Destination', 'Month', 'Duration (days)', 'Traveler gender',
#     'Traveler nationality', 'Accommodation type', 'Accommodation cost',
#     'Transportation cost'
# ]
# df = df.dropna(subset=essential_columns)

# # Seleccionar columnas relevantes para el nuevo conjunto de datos
# new_dataset = df[[
#     'Destination', 'Month', 'Duration (days)', 'Traveler gender',
#     'Traveler nationality', 'Accommodation type', 'Accommodation cost',
#     'Transportation cost'
# ]]

# # Guardar el nuevo conjunto de datos en un archivo CSV
# new_dataset.to_csv('cleaned_travel_dataset.csv', index=False)

# # Mostrar las primeras filas para verificar
# print(new_dataset.head())

# from google.colab import drive
# drive.mount('/content/drive')

"""'''
Módulo base_conocimiento.py (Reglas)
===========================
Este módulo contiene la implementación de la Base de Conocimientos del sistema basado en conocimientos (KBS).
Se encarga de almacenar y aplicar reglas de recomendación de destinos en función de criterios como presupuesto,
duración del viaje, mes de viaje y preferencias de hospedaje.


Método de Similitud Utilizado:
------------------------------
Este sistema utiliza **similitud de coseno** para recomendar destinos de viaje.
Matemáticamente, la similitud de coseno se define como:

    similarity(A, B) = (A ⋅ B) / (||A|| ||B||)

Donde:
- **A** es el vector de entrada del usuario con atributos normalizados (`presupuesto`, `duración promedio`, `mes`).
- **B** es cada destino en el dataset, también normalizado.
- **A ⋅ B** es el producto punto de los vectores.
- **||A||** y **||B||** son las normas euclidianas de los vectores.

Este método mide qué tan similares son dos puntos en el espacio, considerando solo la dirección y no la magnitud.
En este caso, en lugar de realizar un filtrado estricto, el sistema encuentra los destinos más similares al perfil
 del usuario en términos de costos, duración y fecha del viaje.
'''
"""
import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler
import numpy as np
import json
import Rule as rl

class BaseConocimiento:
    def __init__(self, travel_data):
        self.travel_data = travel_data.copy()
        self.travel_data["Total cost"] = self.travel_data["Accommodation cost"] + self.travel_data["Transportation cost"]
        
        # Inferir clima aproximado según el mes (simplificado)
        self.travel_data["Clima"] = self.travel_data["Month"].apply(
            lambda x: "soleado" if x in [6, 7, 8] else "templado" if x in [3, 4, 5, 9, 10, 11] else "frío"
        )
        
        self.scaler = MinMaxScaler()
        self.normalized_data = self.scaler.fit_transform(
            self.travel_data[["Total cost", "Duration (days)", "Month"]]
        )
        self.rules = self.load_rules()

    def load_rules(self):
        with open("rules.json", "r") as f:
            rules_config = json.load(f)["rules"]
        rules = []
        for rule in rules_config:
            if rule["type"] == "cosine_similarity":
                rules.append(rl.CosineSimilarityRule(self.scaler, self.normalized_data))
            elif rule["type"] == "threshold":
                rules.append(rl.ThresholdRule(rule["threshold"], rule["column"]))
            elif rule["type"] == "equality":
                rules.append(rl.EqualityRule(rule["column"]))
        return rules

    def calcular_similitud(self, presupuesto, duracion_min, duracion_max, mes, cantidad_viajeros):
        user_input = [presupuesto * cantidad_viajeros, (duracion_min + duracion_max) / 2, mes]  # Ajustar costo por viajeros
        results = [rule.apply(user_input, self.travel_data) for rule in self.rules]
        return np.mean(results, axis=0)

    def recomendar_destinos(self, presupuesto, duracion_min, duracion_max, mes, tipo_hospedaje=None, preferencia_clima=None, cantidad_viajeros=1):
        self.travel_data["Similarity"] = self.calcular_similitud(presupuesto, duracion_min, duracion_max, mes, cantidad_viajeros)
        destinos_filtrados = self.travel_data.copy()

        # Filtros
        destinos_filtrados = destinos_filtrados[destinos_filtrados["Total cost"] <= presupuesto * cantidad_viajeros]
        if tipo_hospedaje:
            destinos_filtrados = destinos_filtrados[destinos_filtrados["Accommodation type"] == tipo_hospedaje]
        if preferencia_clima:
            destinos_filtrados = destinos_filtrados[destinos_filtrados["Clima"] == preferencia_clima]
        
        if destinos_filtrados.empty:
            return pd.DataFrame()
        
        destinos_recomendados = destinos_filtrados.sort_values(by="Similarity", ascending=False)
        return destinos_recomendados[["Destination", "Total cost", "Duration (days)", "Accommodation type", "Clima", "Similarity"]].head(6)

        continuar = int(input("Desea continuar? (1: Sí, 0: No): "))
        print("\n")

    